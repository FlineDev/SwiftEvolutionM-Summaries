# Swift Opt-In Reflection Metadata (Summary)

* Full Proposal: [SE-0379](https://github.com/apple/swift-evolution/blob/main/proposals/0379-opt-in-reflection-metadata.md)
* Summary Author: [Cihat Gündüz](https://fline.dev/about)
* Article: [Swift Evolution Monthly: December ‘22](https://www.fline.dev/swift-evolution-monthly-december-22/#se-0379-swift-opt-in-reflection-metadata)


Are you making use of reflection APIs in Swift in your apps today? As a reminder: Reflection is the act of building your logic upon the structure of your (or someone else’s) Swift code. For example, for a type `Person` you could use the `Mirror`type and pass it an object of type `Person` to get information about the properties and their names to act accordingly. You might think that this seems useful in some rare scenarios, but I’m sure you’ve used reflection APIs already. If you’ve done any kind of debugging, chances are that you might have used one of the `print`, `debugPrint` or `dump` methods and passed them an object already. Guess what, the reason these give you some useful information is that they are making use of Reflection under the hoods!

But independent of if you’re planning on making use of reflection APIs explicitly sometime in the future or not, this proposal will profit anyone: Because it introduces fine-grained control over when reflection on a type is needed and when it is not and provides compile-time feedback. Basically, up until now, all code had to be compiled in a way that made reflection possible by adding metadata to your app binary, such as the property names `firstName` and `lastName` for a type like `Person` – just in case some library or SDK you were using relied on reflection like SwiftUI does for tracking changes in your model. Of course, this means that it is much easier to reverse-engineer our compiled code back to its original code form with these kinds of metadata than it would be if the name of the property wouldn’t be clear. Also, it is currently possible to completely turn off reflection metadata generation without any compiler warnings, which can lead to unexpected behavior.

This proposal aims to solve that by introducing a new `Reflectable` protocol to mark types that should support reflection metadata explicitly, so only for those types full metadata is provided. A migration path is provided so existing code doesn’t break immediately. Instead, Swift users will (probably) get a warning at first, so they can migrate their types over to `Reflectable`. Only once Swift 6 is out, the new behavior will be turned on by default (use the flag `-enable-full-reflection-metadata` to turn it on before that). For those who want to use reflection explicitly in their own code, they’ll be able to specify that their functions only work on types that conform to `Reflectable` and this way can be sure they can reflect on the provided data. And for those who just want to use APIs that use reflection under the hood, they will get an error at compile-time if they pass in data that doesn’t conform to `Reflectable`, making Swift reflection code safer, more reliable, and harder to reverse-engineer all at the same time.
